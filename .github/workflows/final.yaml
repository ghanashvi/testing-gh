###############################################################################
# Workflow: Build ➜ Scan (per image) ➜ Promote (only clean images)
###############################################################################
name: Build ➜ Scan ➜ Promote

on:
  repository_dispatch:
    types: [app-code-change]

###############################################################################
# Global environment variables
###############################################################################
env:
  WORKLOAD_IDENTITY_PROVIDER: 'projects/906017862008/locations/global/workloadIdentityPools/github-pool/providers/github-provider'
  SERVICE_ACCOUNT:            'ci-image-builder@axial-edition-463510-p5.iam.gserviceaccount.com'

  QUAR_IMAGE_REGISTRY:   us-central1-docker.pkg.dev/axial-edition-463510-p5/quarantine-repo
  SECURE_IMAGE_REGISTRY: us-central1-docker.pkg.dev/decent-creek-464109-p6/secure-repo
  GAR_LOCATION:          us-central1
  ODS_LOCATION:          us

###############################################################################
# Job 1: Build and push changed Dockerfiles
###############################################################################
jobs:
  build:
    runs-on: ubuntu-latest
    permissions: { contents: read, id-token: write }

    outputs:
      built_images: ${{ steps.collect.outputs.images_json }}
      repo_name:    ${{ steps.clone_repo.outputs.REPO_NAME }}
      commit_tag:   ${{ github.event.client_payload.sha }}

    steps:
      # Checkout orchestration repository
      - uses: actions/checkout@v3

      # Clone application repository
      - id: clone_repo
        name: Clone application repository
        run: |
          REPO_FULL="${{ github.event.client_payload.repository }}"
          REPO_NAME="${REPO_FULL#*/}"
          git clone https://x-access-token:${{ secrets.CI_PAT }}@github.com/$REPO_FULL "$REPO_NAME"
          cd "$REPO_NAME"
          git checkout "${{ github.event.client_payload.sha }}"
          echo "REPO_NAME=$REPO_NAME" >> "$GITHUB_OUTPUT"

      # Resolve base commit
      - id: base
        name: Resolve base commit
        run: |
          cd "${{ steps.clone_repo.outputs.REPO_NAME }}"
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            echo "sha=$(git rev-parse HEAD~1)" >> "$GITHUB_OUTPUT"
          else
            echo "sha=4b825dc642cb6eb9a060e54bf8d69288fbee4904" >> "$GITHUB_OUTPUT"
          fi

      # Detect changed Dockerfiles
      - id: diff
        name: Detect changed Dockerfiles
        uses: tj-actions/changed-files@v46
        with:
          token: ${{ github.token }}
          path: ${{ steps.clone_repo.outputs.REPO_NAME }}
          base_sha: ${{ steps.base.outputs.sha }}
          sha:      ${{ github.event.client_payload.sha }}
          use_rest_api: false
          files: |
            **/Dockerfile*

      # Authenticate to Google Cloud
      - uses: google-github-actions/auth@v1
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account:            ${{ env.SERVICE_ACCOUNT }}

      # Set up Buildx builder
      - uses: docker/setup-buildx-action@v2

      # Configure Docker for Artifact Registry
      - name: Configure docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev

      # Build and push each changed Dockerfile
      - name: Build and push images
        run: |
          set -e
          REPO="${{ steps.clone_repo.outputs.REPO_NAME }}"
          SHA="${{ github.event.client_payload.sha }}"
          cd "$REPO"
          > /tmp/built.txt
          for FILE in ${{ steps.diff.outputs.all_changed_files }}; do
            [[ "$FILE" != *Dockerfile* ]] && continue
            DIR=$(dirname "$FILE")
            COMP=$(basename "$FILE" | sed -E 's/^Dockerfile[-\.]?//')
            COMP=${COMP:-default}
            TAG="$REPO-$COMP:insecure-$SHA"
            FULL="$QUAR_IMAGE_REGISTRY/$TAG"
            docker build -f "$FILE" -t "$FULL" "$DIR"
            docker push "$FULL"
            echo "$FULL" >> /tmp/built.txt
          done

      # Collect built image list as JSON
      - id: collect
        name: Collect built image list
        run: |
          if [ -s /tmp/built.txt ]; then
            jq -Rsc 'split("\n")[:-1]' /tmp/built.txt > /tmp/list.json
            echo "images_json=$(cat /tmp/list.json)" >> "$GITHUB_OUTPUT"
          else
            echo "images_json=[]" >> "$GITHUB_OUTPUT"
          fi

###############################################################################
# Job 2: Scan each image and promote only clean ones
###############################################################################
  scan_and_promote:
    needs: build
    if: needs.build.outputs.built_images != '[]'
    runs-on: ubuntu-latest
    permissions:
      id-token: write     # for Artifact Registry
      packages: write     # for GHCR
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.build.outputs.built_images) }}

    steps:
      # Checkout for workspace and GHCR login context
      - uses: actions/checkout@v3

      # Authenticate to Google Cloud
      - uses: google-github-actions/auth@v1
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account:            ${{ env.SERVICE_ACCOUNT }}

      # Run On‑Demand scan and output scan_pass flag
      - id: scan
        name: On‑Demand scan (does not stop job)
        continue-on-error: true
        env:
          IMG:        ${{ matrix.image }}
          ODS_LOC:    ${{ env.ODS_LOCATION }}
          CREDS:      ${{ env.GOOGLE_APPLICATION_CREDENTIALS }}
          PROJECT_ID: ${{ env.GOOGLE_CLOUD_PROJECT }}
        run: |
          docker run --rm \
            -e CLOUDSDK_CORE_DISABLE_PROMPTS=1 \
            -e GOOGLE_APPLICATION_CREDENTIALS=/creds.json \
            -e CLOUDSDK_CORE_PROJECT=$PROJECT_ID \
            -v "$CREDS":/creds.json:ro \
            google/cloud-sdk:latest /bin/bash -c "
              set -e
              gcloud auth login --quiet --cred-file=/creds.json --brief
              SCAN_ID=\$(gcloud artifacts docker images scan \"$IMG\" \
                          --location='$ODS_LOC' --remote --quiet \
                          --format='value(response.scan)')
              COUNT=\$(gcloud artifacts docker images list-vulnerabilities \$SCAN_ID \
                        --location='$ODS_LOC' --format='value(name)' | wc -l)
              if [ \$COUNT -gt 0 ]; then
                echo 'scan_pass=false' >> $GITHUB_OUTPUT
              else
                echo 'scan_pass=true'  >> $GITHUB_OUTPUT
              fi
            "

      # Configure docker for secure registry (only if scan passed)
      - name: Docker login secure registry
        if: steps.scan.outputs.scan_pass == 'true'
        run: gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev

      # Copy digest to secure repo and push
      - id: promote
        name: Promote to secure repo
        if: steps.scan.outputs.scan_pass == 'true'
        env:
          QUAR:   ${{ env.QUAR_IMAGE_REGISTRY }}
          SECURE: ${{ env.SECURE_IMAGE_REGISTRY }}
        run: |
          SRC="${{ matrix.image }}"
          DST=$(echo "$SRC" | sed "s|$QUAR|$SECURE|" | sed "s/:insecure-/:secure-/")
          docker pull "$SRC"
          docker tag  "$SRC" "$DST"
          docker push "$DST"
          echo "dst=$DST" >> "$GITHUB_OUTPUT"

      # Push tag to GHCR for images that passed
      - name: Push to GHCR
        if: steps.scan.outputs.scan_pass == 'true'
        env:
          COMMIT_TAG: ${{ needs.build.outputs.commit_tag }}
          DST:        ${{ steps.promote.outputs.dst }}
        run: |
          COMPONENT=$(basename "$DST" | cut -d':' -f1)
          GHCR="ghcr.io/${{ github.repository_owner }}/$COMPONENT:secure-$COMMIT_TAG"
          echo "${{ github.token }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
          docker tag "$DST" "$GHCR"
          docker push "$GHCR"

      # Fail this matrix run if scan_pass is false
      - name: Fail when scan fails
        if: steps.scan.outputs.scan_pass != 'true'
        run: exit 1
        
