################################################################################
# Workflow : Build ➜ On‑Demand Scan (fail on *any* vuln) ➜ Promote
################################################################################
name: Build ➜ Scan ➜ Promote

on:
  repository_dispatch:
    types: [app-code-change]

###############################################################################
# ------------------------------  Global ENV  ---------------------------------
# Change only these lines if your project / repo / region changes.
###############################################################################
env:
  # Workload‑Identity Federation (no JSON keys in repo)
  WORKLOAD_IDENTITY_PROVIDER: 'projects/906017862008/locations/global/workloadIdentityPools/github-pool/providers/github-provider'
  SERVICE_ACCOUNT:            'ci-image-builder@axial-edition-463510-p5.iam.gserviceaccount.com'

  # Docker/Artifact Registry hosts
  QUAR_IMAGE_REGISTRY:   us-central1-docker.pkg.dev/axial-edition-463510-p5/quarantine-repo
  SECURE_IMAGE_REGISTRY: us-central1-docker.pkg.dev/decent-creek-464109-p6/secure-repo
  GAR_LOCATION:          us-central1   # region for docker login
  ODS_LOCATION:          us           # region for *On‑Demand Scanning*

  # Polling controls
  POLL_INTERVAL: 10      # seconds between API checks
  MAX_ATTEMPTS:  36      # 36 × 10 s  ≈ 6 minutes

###############################################################################
# JOB 1 : Build & push changed Dockerfiles to *quarantine* repo
###############################################################################
jobs:
  build:
    runs-on: ubuntu-latest
    permissions: { contents: read, id-token: write }

    # ----- Pass data to later jobs -----
    outputs:
      built_images: ${{ steps.collect.outputs.images_json }}
      repo_name:    ${{ steps.clone_repo.outputs.REPO_NAME }}
      commit_tag:   ${{ github.event.client_payload.sha }}

    steps:
    # 1️⃣  Checkout orchestration repo
    - uses: actions/checkout@v3

    # 2️⃣  Clone application repo at dispatch SHA
    - name: Clone Source Repository
      id: clone_repo
      run: |
        REPO_FULL="${{ github.event.client_payload.repository }}"
        REPO_NAME="${REPO_FULL#*/}"
        git clone https://x-access-token:${{ secrets.CI_PAT }}@github.com/$REPO_FULL "$REPO_NAME"
        cd "$REPO_NAME"
        git checkout "${{ github.event.client_payload.sha }}"
        echo "REPO_NAME=$REPO_NAME" >> "$GITHUB_OUTPUT"

    # 3️⃣  Safe base SHA (empty‑tree on first run)
    - name: Resolve base SHA
      id: base
      run: |
        cd "${{ steps.clone_repo.outputs.REPO_NAME }}"
        if git rev-parse HEAD~1 >/dev/null 2>&1; then
          echo "sha=$(git rev-parse HEAD~1)" >> "$GITHUB_OUTPUT"
        else
          echo "sha=4b825dc642cb6eb9a060e54bf8d69288fbee4904" >> "$GITHUB_OUTPUT"
        fi

    # 4️⃣  Detect changed Dockerfiles only
    - id: diff
      name: Detect changed Dockerfiles
      uses: tj-actions/changed-files@v46
      with:
        token:     ${{ github.token }}
        path:      ${{ steps.clone_repo.outputs.REPO_NAME }}
        base_sha:  ${{ steps.base.outputs.sha }}
        sha:       ${{ github.event.client_payload.sha }}
        use_rest_api: false
        files: |
          **/Dockerfile*

    # 5️⃣  GCP auth (via Workload‑Identity Federation)
    - uses: google-github-actions/auth@v1
      with:
        workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
        service_account:            ${{ env.SERVICE_ACCOUNT }}

    # 6️⃣  Buildx & Docker login
    - uses: docker/setup-buildx-action@v2
    - name: Configure Docker for GAR
      run: gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev

    # 7️⃣  Build & push each changed Dockerfile
    - name: Build & Push
      run: |
        set -e
        REPO="${{ steps.clone_repo.outputs.REPO_NAME }}"
        SHA="${{ github.event.client_payload.sha }}"
        cd "$REPO"
        : > /tmp/built_images.txt

        for FILE in ${{ steps.diff.outputs.all_changed_files }}; do
          [[ "$FILE" != *Dockerfile* ]] && continue
          DIR=$(dirname "$FILE")
          COMP=$(basename "$FILE" | sed -E 's/^Dockerfile[-\.]?//')
          COMP=${COMP:-default}
          TAG="$REPO-$COMP:insecure-$SHA"
          FULL="$QUAR_IMAGE_REGISTRY/$TAG"

          echo "::group::Building $FULL"
          docker build -f "$FILE" -t "$FULL" "$DIR"
          docker push "$FULL"
          echo "::endgroup::"

          echo "$FULL" >> /tmp/built_images.txt
        done

    # 8️⃣  Convert image list → JSON for matrix
    - id: collect
      name: Collect built images
      run: |
        if [ -s /tmp/built_images.txt ]; then
          jq -Rsc 'split("\n")[:-1]' /tmp/built_images.txt > /tmp/list.json
          echo "images_json=$(cat /tmp/list.json)" >> "$GITHUB_OUTPUT"
        else
          echo "images_json=[]" >> "$GITHUB_OUTPUT"
        fi

###############################################################################
# JOB 2 : On‑Demand Scan – fail if *any* vulnerability row exists
###############################################################################
  ods_scan:
    needs: build
    if: needs.build.outputs.built_images != '[]'
    runs-on: ubuntu-latest
    permissions: { id-token: write }
    strategy:
      matrix:
        image: ${{ fromJson(needs.build.outputs.built_images) }}

    steps:
    # 1️⃣  GCP auth
    - uses: google-github-actions/auth@v1
      with:
        workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
        service_account:            ${{ env.SERVICE_ACCOUNT }}

    # 2️⃣  Trigger ODS scan, poll until results, fail on ANY vuln
    - name: ODS scan & gate (block on LOW+)
      env:
        IMG:            ${{ matrix.image }}
        ODS_LOCATION:   ${{ env.ODS_LOCATION }}
        POLL_INTERVAL:  ${{ env.POLL_INTERVAL }}
        MAX_ATTEMPTS:   ${{ env.MAX_ATTEMPTS }}
      run: |
        set -e
        echo "::notice::Starting On‑Demand scan for $IMG"
        SCAN_ID=$(gcloud artifacts docker images scan "$IMG" \
                    --location="$ODS_LOCATION" \
                    --format='value(response.scan)')
        echo "::notice::Scan ID = $SCAN_ID"

        # Wait until at least one row OR timeout
        for (( i=1; i<=MAX_ATTEMPTS; i++ )); do
          ROWS=$(gcloud artifacts docker images list-vulnerabilities "$SCAN_ID" \
                   --location="$ODS_LOCATION" \
                   --format='value(name)' | wc -l)
          [[ "$ROWS" -gt 0 ]] && break
          sleep "$POLL_INTERVAL"
        done

        if [[ "$ROWS" -eq 0 ]]; then
          echo "::error::Scan timed out (no results)"
          exit 1
        fi

        echo "::error::Vulnerabilities detected (rows=$ROWS).  Blocking promotion."
        gcloud artifacts docker images list-vulnerabilities "$SCAN_ID" \
          --location="$ODS_LOCATION" \
          --format='table(vulnerability.effectiveSeverity, vulnerability.shortDescription)'
        exit 1

###############################################################################
# JOB 3 : Promote – executes only if ods_scan succeeded (no vulns)
###############################################################################
  promote_secure:
    needs: [build, ods_scan]
    if: needs.ods_scan.result == 'success'
    runs-on: ubuntu-latest
    permissions: { id-token: write, packages: write }
    strategy:
      matrix:
        image: ${{ fromJson(needs.build.outputs.built_images) }}

    steps:
    # 1️⃣  GCP auth
    - uses: google-github-actions/auth@v1
      with:
        workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
        service_account:            ${{ env.SERVICE_ACCOUNT }}

    # 2️⃣  Docker login (secure repo host)
    - name: Configure Docker for GAR
      run: gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev

    # 3️⃣  Copy digest → secure repo, retag with secure‑<sha>
    - id: copy
      name: Copy to secure repo
      run: |
        SRC="${{ matrix.image }}"
        DST=$(echo "$SRC" \
               | sed "s|$QUAR_IMAGE_REGISTRY|$SECURE_IMAGE_REGISTRY|" \
               | sed "s/:insecure-/:secure-/")
        gcloud artifacts docker images copy "$SRC" --destination="$DST" --quiet
        echo "dst=$DST" >> "$GITHUB_OUTPUT"

    # 4️⃣  Push same digest/tag to GHCR
    - name: Push to GHCR
      env:
        COMMIT_TAG: ${{ needs.build.outputs.commit_tag }}
        DST:        ${{ steps.copy.outputs.dst }}
      run: |
        COMPONENT=$(basename "$DST" | cut -d':' -f1)
        GHCR="ghcr.io/${{ github.repository_owner }}/$COMPONENT:secure-$COMMIT_TAG"
        docker pull "$DST"
        echo "${{ github.token }}" | docker login ghcr.io -u ${GITHUB_ACTOR} --password-stdin
        docker tag "$DST" "$GHCR"
        docker push "$GHCR"
